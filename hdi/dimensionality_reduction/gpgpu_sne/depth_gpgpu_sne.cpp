#ifndef __APPLE__

#define _USE_MATH_DEFINES
#include <cmath>
#include <random>
#include "hdi/utils/scoped_timers.h"
#include "hdi/utils/log_helper_functions.h"
#include "depth_gpgpu_sne.h"
#include "depth_compute_shaders.h"

// Do or do not add query timer functions
#ifdef QUERY_TIMER_ENABLED
  #define startTimer(type) startTimerQuery(type)
  #define stopTimer() stopTimerQuery()
  #define updateTimer(type, iterations) updateTimerQuery(type, iterations)
  #define reportTimer(type, name, iteration) reportTimerQuery(type, name, iteration)
#else
  #define startTimer(type)
  #define stopTimer()
  #define updateTimer(type, iterations)
  #define reportTimer(type, name, iteration)
#endif

namespace {
  // Magic resolution scaling numbers
  constexpr bool adaptiveResolution = true;
  constexpr unsigned int fixedFieldSize = 40;
  constexpr unsigned int minFieldSize = 5;
  constexpr float pixelRatio = 2.0f;
  constexpr float functionSupport = 6.5f;
  constexpr int seedOffset = 7; // Generated by fair d20 die roll

  typedef hdi::dr::embedding_t embedding_t;
  typedef hdi::dr::sparse_matrix_t sparse_matrix_t;
  typedef hdi::dr::Point3D Point3D;
  typedef hdi::dr::Bounds3D Bounds3D;

  template <typename T>
  inline T next1D() {
    constexpr T next1DDiv = static_cast<T>(1) / static_cast<T>(RAND_MAX + 1);
    return static_cast<T>(rand()) * next1DDiv;
  }

  Bounds3D computeEmbeddingBounds(const embedding_t* embedding, 
                                  float padding) {
    const auto& points = embedding->getContainer();

    // Instantiate bounds at infinity
    Bounds3D bounds;
    bounds.min.x = bounds.min.y = bounds.min.z = std::numeric_limits<float>::max();
    bounds.max.x = bounds.max.y = bounds.max.z = -std::numeric_limits<float>::max();

    // Iterate over bounds to set the largest
    for (int i = 0; i < embedding->numDataPoints(); ++i) {
      const auto x = points[i * 4 + 0];
      const auto y = points[i * 4 + 1];
      const auto z = points[i * 4 + 2];

      bounds.min.x = std::min<float>(x, bounds.min.x);
      bounds.max.x = std::max<float>(x, bounds.max.x);
      bounds.min.y = std::min<float>(y, bounds.min.y);
      bounds.max.y = std::max<float>(y, bounds.max.y);
      bounds.min.z = std::min<float>(z, bounds.min.z);
      bounds.max.z = std::max<float>(z, bounds.max.z);
    }
    
    // Add extra padding if requested
    if (padding != 0.f) {
      const float x_padding = (bounds.max.x - bounds.min.x) * 0.5f * padding;
      const float y_padding = (bounds.max.y - bounds.min.y) * 0.5f * padding;
      const float z_padding = (bounds.max.z - bounds.min.z) * 0.5f * padding;

      bounds.min.x -= x_padding;
      bounds.max.x += x_padding;
      bounds.min.y -= y_padding;
      bounds.max.y += y_padding;
      bounds.min.z -= z_padding;
      bounds.max.z += z_padding;
    }

    return bounds;
  }
}

namespace  hdi::dr {
  GpgpuDepthSneCompute::GpgpuDepthSneCompute()
  : _initialized(false),
    _adaptive_resolution(adaptiveResolution),
    _resolution_scaling(pixelRatio),
    _logger(nullptr) {
    // ...
  }

  GpgpuDepthSneCompute::~GpgpuDepthSneCompute() {
    if (_initialized) {
      clean();
    }
  }

  void GpgpuDepthSneCompute::initialize(const embedding_t* embedding, 
                                        const TsneParameters& params, 
                                        const sparse_matrix_t& P) {
    glClearColor(0, 0, 0, 0);

    _params = params;
    _bounds = computeEmbeddingBounds(embedding, 0.f);
    const int n = embedding->numDataPoints();
    _depthFieldComputation.initialize(n);

    // Initialize rng, yeah std::rand() is bad.
    std::srand(_params._seed + seedOffset);

#ifdef QUERY_TIMER_ENABLED
  // Generate timer query handles and reset values
  glGenQueries(_timerHandles.size(), _timerHandles.data());
  _timerValues.fill({0l, 0l });
#endif // QUERY_TIMER_ENABLED

    // Create shader programs
    try {
      for (auto& program : _programs) {
        program.create();
      }

      // Attach shaders
      _programs[PROGRAM_INTERP_FIELDS].addShader(COMPUTE, depth_3D_interpolation_src);
      _programs[PROGRAM_SUM_Q].addShader(COMPUTE, depth_sumq_src);
      _programs[PROGRAM_POSITIVE_FORCES].addShader(COMPUTE, depth_positive_forces_src);
      _programs[PROGRAM_GRADIENTS].addShader(COMPUTE, depth_gradients_src);
      _programs[PROGRAM_UPDATE].addShader(COMPUTE, depth_update_src);
      _programs[PROGRAM_BOUNDS].addShader(COMPUTE, depth_bounds_src);
      _programs[PROGRAM_CENTERING].addShader(COMPUTE, depth_centering_src);

      for (auto& program : _programs) {
        program.build();

        // Most progams use this and it remains constant throughout runtime
        program.bind();
        if (program.getUniformLocation("num_points") != -1) {
          program.uniform1ui("num_points", n);
        }
        if (program.getUniformLocation("inv_num_points") != -1) {
          program.uniform1f("inv_num_points", 1.f / static_cast<float>(n));
        }
        program.release();
      }
    } catch (const ErrorMessageException& e) {
      std::cerr << e.what() << std::endl;
    }
    
    // Create and initialize buffers
    {
      const LinearProbabilityMatrix LP = linearizeProbabilityMatrix(embedding, P);
      const std::vector<float> zeroes(4 * n, 0);
      const std::vector<float> ones(4 * n, 1);
      glGenBuffers(_buffers.size(), _buffers.data());

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_POSITION]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, n * sizeof(Point3D), nullptr, GL_STREAM_DRAW);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_INTERP_FIELDS]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, n * 4 * sizeof(float), zeroes.data(), GL_STATIC_DRAW);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_SUM_Q]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, 128 * sizeof(float), nullptr, GL_STREAM_DRAW);
      
      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_NEIGHBOUR]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, LP.neighbours.size() * sizeof(uint32_t), LP.neighbours.data(), GL_STATIC_DRAW);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_PROBABILITIES]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, LP.probabilities.size() * sizeof(float), LP.probabilities.data(), GL_STATIC_DRAW);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_INDEX]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, LP.indices.size() * sizeof(int), LP.indices.data(), GL_STATIC_DRAW);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_POSITIVE_FORCES]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, n * sizeof(Point3D), nullptr, GL_STREAM_READ);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_GRADIENTS]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, n * sizeof(Point3D), nullptr, GL_STREAM_READ);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_PREV_GRADIENTS]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, n * sizeof(Point3D), zeroes.data(), GL_STREAM_READ);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_GAIN]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, n * sizeof(Point3D), ones.data(), GL_STREAM_READ);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_BOUNDS]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, 4 * sizeof(Point3D), ones.data(), GL_STREAM_READ);

      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_BOUNDS_REDUCE_ADD]);
      glBufferData(GL_SHADER_STORAGE_BUFFER, 2 * 128 * sizeof(Point3D), ones.data(), GL_STREAM_READ);
      
      glAssert("Initialized buffers");
    }

    _initialized = true;
  }
  
  void GpgpuDepthSneCompute::clean() {
    if (_initialized) {
      for (auto& program : _programs) {
        program.destroy();
      }
#ifdef QUERY_TIMER_ENABLED
      glDeleteQueries(_timerHandles.size(), _timerHandles.data());
#endif // QUERY_TIMER_ENABLED
      glDeleteBuffers(_buffers.size(), _buffers.data());
      _initialized = false;
    }
  }
  
  void GpgpuDepthSneCompute::compute(embedding_t* embedding, 
                                     float exaggeration, 
                                     unsigned iteration, 
                                     float mult) {
    const int n = embedding->numDataPoints();

    // Copy embedding positional data over to device
    if (iteration == 0) {
      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_POSITION]);
      glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, n * sizeof(Point3D), embedding->getContainer().data());
    }

    // Compute bounds of the embedding and add 10% border around it
    computeBounds(n, 0.1f);

    // Capture padded bounds from gpu
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_BOUNDS]);
    glGetBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, 2 * sizeof(Point3D), &_bounds);

    // Generate random camera view
    updateView();
    
    // Determine fields texture dimension (this has a rather significant impact in 3d)
    Point3D range = _bounds.range();
    uint32_t w = _adaptive_resolution 
      ? std::max((unsigned int)(range.x * _resolution_scaling), minFieldSize) 
      : fixedFieldSize;
    uint32_t h = _adaptive_resolution 
      ? std::max((unsigned int)(range.y * _resolution_scaling), minFieldSize) 
      : (int) (fixedFieldSize * (range.y / range.x));
    uint32_t d = 8; // Fixed z-resolution // TODO: Extract magic number
    
    // Compute depth and fields texture
    _depthFieldComputation.compute(w, h, d,
                                  functionSupport, n,
                                  _buffers[BUFFER_POSITION], 
                                  _buffers[BUFFER_BOUNDS],
                                  _bounds, viewMatrix);

    // Calculate normalization sum and interpolate fields to sample points
    float sum_Q = 0.f;
    interpolateFields(n, &sum_Q);
    sumQ(n, &sum_Q);
    if (sum_Q == 0.f) {
      std::cout << "SUM_Q was 0, bring out thine debuggers" << std::endl;
      exit(0);
      return;
    }
    
    // Compute gradient from forces
    computeGradients(n, sum_Q, exaggeration);

    // Update embedding
    updatePoints(n, iteration, mult);
    updateEmbedding(n, exaggeration, iteration);
    
    // Update timer handles 
    updateTimer(TIMER_INTERP_FIELDS, iteration);
    updateTimer(TIMER_SUM_Q, iteration);
    updateTimer(TIMER_GRADIENTS, iteration);
    updateTimer(TIMER_UPDATE, iteration);
    updateTimer(TIMER_BOUNDS, iteration);
    updateTimer(TIMER_CENTERING, iteration);

    // On final iteration, update host embedding data
    if (iteration >= _params._iterations - 1) {
      glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
      glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_POSITION]);
      glGetBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, n * sizeof(Point3D), embedding->getContainer().data());

      // Output timer averages
      reportTimer(TIMER_INTERP_FIELDS, "Interp", iteration);
      reportTimer(TIMER_SUM_Q, "Sum Q", iteration);
      reportTimer(TIMER_GRADIENTS, "Grads", iteration);
      reportTimer(TIMER_UPDATE, "Update", iteration);
      reportTimer(TIMER_BOUNDS, "Bounds", iteration);
      reportTimer(TIMER_CENTERING, "Center", iteration);
    }
  }

  void GpgpuDepthSneCompute::updateView() {
    constexpr float pi2 = 2.f * static_cast<float>(M_PI);
    const float r1 = next1D<float>(), r2 = next1D<float>(), r3 = next1D<float>();

    // Generate random point on unit sphere
    float z = 1.f - 2.f * r1;
    float r = std::sqrtf(1.f - z * z);
    float phi = pi2 * r2;
    float x = std::cosf(phi) * r;
    float y = std::sinf(phi) * r;

    // Generate random angle around vector
    float theta = 360.f * r3;

    // Center point in [-0.5, 0.5], rotate, and uncenter again
    viewMatrix = QMatrix4x4();
    viewMatrix.translate(0.5f, 0.5f, 0.5f); // shift away from center again
    viewMatrix.rotate(theta, x, y, z);
    viewMatrix.translate(-0.5f, -0.5f, -0.5f); // shift to center
  }

  void GpgpuDepthSneCompute::computeBounds(unsigned n, float padding) {
    auto& program = _programs[PROGRAM_BOUNDS];
    program.bind();

    // Bind buffers for this shader
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_POSITION]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_BOUNDS_REDUCE_ADD]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, _buffers[BUFFER_BOUNDS]);

    // Set uniforms for this shader
    program.uniform1f("padding", padding);

    // Run shader (dimensionality reduction in single group)
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    startTimer(TIMER_BOUNDS);
    program.uniform1ui("iteration", 0u);
    glDispatchCompute(128, 1, 1);
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    program.uniform1ui("iteration", 1u);
    glDispatchCompute(1, 1, 1);
    stopTimer();

    program.release();
  }

  void GpgpuDepthSneCompute::interpolateFields(unsigned n, float* sum_Q) {
    auto& program = _programs[PROGRAM_INTERP_FIELDS];
    program.bind();
    
    // Bind the textures for this shader
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D_ARRAY, _depthFieldComputation.depthTexture());
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_3D, _depthFieldComputation.field3DTexture());

    // Bind buffers for this shader
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_POSITION]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_INTERP_FIELDS]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, _buffers[BUFFER_BOUNDS]);

    // Bind uniforms for this shader
    program.uniformMatrix4f("transformation", viewMatrix.data());
    program.uniform1i("depth_textures", 0);
    program.uniform1i("fields_texture", 1);

    // Dispatch compute shader
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT | GL_TEXTURE_FETCH_BARRIER_BIT);
    startTimer(TIMER_INTERP_FIELDS);
    glDispatchCompute(128, 1, 1);
    stopTimer();
    
    program.release();
  }

  void GpgpuDepthSneCompute::sumQ(unsigned in, float* sum_Q) {
    auto& program = _programs[PROGRAM_SUM_Q];
    program.bind();

    // Bind buffers for this shader
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_INTERP_FIELDS]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_SUM_Q]);

    // Run shader twice (dimensionality reduction in two steps)
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    startTimer(TIMER_SUM_Q);
    program.uniform1ui("iteration", 0u);
    glDispatchCompute(128, 1, 1);
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    program.uniform1ui("iteration", 1u);
    glDispatchCompute(1, 1, 1);
    stopTimer();

    // Copy SUMQ result back to host
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, _buffers[BUFFER_SUM_Q]);
    glGetBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, sizeof(float), sum_Q);
    
    program.release();
  }

  void GpgpuDepthSneCompute::computeGradients(unsigned n, float sum_Q, float exaggeration) {
    startTimer(TIMER_GRADIENTS);

    // Reduce add positive forces (performance hog, 60K reduce-adds over ~250 points)
    {
      auto& program = _programs[PROGRAM_POSITIVE_FORCES];
      program.bind();

      // Bind buffers for this shader
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_POSITION]);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_NEIGHBOUR]);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, _buffers[BUFFER_PROBABILITIES]);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, _buffers[BUFFER_INDEX]);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, _buffers[BUFFER_POSITIVE_FORCES]);

      // Run shader
      glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
      glDispatchCompute(n, 1, 1);

      program.release();
    }

    // Compute gradients
    {    
      auto& program = _programs[PROGRAM_GRADIENTS];
      program.bind();

      // Bind buffers for this shader
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_POSITIVE_FORCES]);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_INTERP_FIELDS]);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, _buffers[BUFFER_GRADIENTS]);

      // Bind uniforms for this shader
      program.uniform1f("exaggeration", exaggeration);
      program.uniform1f("sum_Q", sum_Q);
      program.uniform1f("inv_sum_Q", 1.0f / sum_Q);

      // Run shader
      glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
      glDispatchCompute(128, 1, 1);

      program.release();
    }

    stopTimer();
  }

  void GpgpuDepthSneCompute::updatePoints(unsigned n, unsigned iteration, float mult) {
    auto& program = _programs[PROGRAM_UPDATE];
    program.bind();

    // Bind buffers for this shader
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_POSITION]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_GRADIENTS]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, _buffers[BUFFER_PREV_GRADIENTS]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, _buffers[BUFFER_GAIN]);
    
    // Bind uniforms for this shader
    program.uniform1f("eta", _params._eta);
    program.uniform1f("minGain", _params._minimum_gain);
    program.uniform1f("mult", mult);

    // Single computation instead of six values
    float iter_mult = 
      (static_cast<double>(iteration) < _params._mom_switching_iter) 
      ? _params._momentum 
      : _params._final_momentum;
    program.uniform1f("iter_mult", iter_mult);

    // Run shader
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    startTimer(TIMER_UPDATE);
    glDispatchCompute(128, 1, 1);
    stopTimer();

    program.release();
  }

  void GpgpuDepthSneCompute::updateEmbedding(unsigned n, float exaggeration, unsigned iteration) {
    auto& program = _programs[PROGRAM_CENTERING];
    program.bind();

    // Bind buffers for this shader
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, _buffers[BUFFER_POSITION]);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, _buffers[BUFFER_BOUNDS]);
    
    // Set uniforms for this shader
    Point3D center = _bounds.center();
    Point3D range = _bounds.range();
    if (exaggeration > 1.2f && range.y < 0.1f) {
      // Enable scaling for small embeddings
      program.uniform1f("scaling", 0.1f / range.y);
    } else {
      program.uniform1f("scaling", 1.f);
    }
    program.uniform3f("center", center.x, center.y, center.z);

    // Run shader
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    startTimer(TIMER_CENTERING);
    glDispatchCompute(128, 1, 1);
    stopTimer();

    program.release();
  }
  
#ifdef QUERY_TIMER_ENABLED
  void GpgpuDepthSneCompute::startTimerQuery(TimerType type) {
    glBeginQuery(GL_TIME_ELAPSED, _timerHandles[type]);
  }

  void GpgpuDepthSneCompute::stopTimerQuery() {
    glEndQuery(GL_TIME_ELAPSED);
  }
  
  void GpgpuDepthSneCompute::updateTimerQuery(TimerType type, unsigned iteration) {
      const auto& handle = _timerHandles[type];
      auto& values = _timerValues[type];

      // Stall until query data for this handle is available
      int i = 0;
      while (!i) {
        glGetQueryObjectiv(handle, GL_QUERY_RESULT_AVAILABLE, &i);
      }
      
      // Obtain query value
      glGetQueryObjecti64v(handle, GL_QUERY_RESULT, &values[TIMER_LAST_QUERY]);
      
      // Compute incremental average
      values[TIMER_AVERAGE] 
        = values[TIMER_AVERAGE] 
        + (values[TIMER_LAST_QUERY] - values[TIMER_AVERAGE]) 
        / (iteration + 1);
  }

  void GpgpuDepthSneCompute::reportTimerQuery(TimerType type, const std::string& name, unsigned iteration) {
    const double ms = static_cast<double>(_timerValues[type][TIMER_AVERAGE]) / 1000000.0;
    utils::secureLogValue(
      _logger, 
      name + " shader average (" + std::to_string(iteration) + " iters, ms)",
      ms);
  }
#endif // QUERY_TIMER_ENABLED
}


#endif // __APPLE__