
#define _USE_MATH_DEFINES
#include <cmath>
#include <algorithm>
#include <random>
#include <string>
#include <QVector3D>
#include <QTransform>
#include "depth_field_computation.h"
#include "hdi/visualization/opengl_helpers.h"
#include "hdi/utils/visual_utils.h"
#include "hdi/utils/log_helper_functions.h"

#define GLSL(name, version, shader) \
  static const char* name = \
  "#version " #version "\n" #shader
  
// Do or do not add query timer functions
#ifdef FIELD_QUERY_TIMER_ENABLED
  #include <deque>
  #define startTimer(type) startTimerQuery(type)
  #define stopTimer() stopTimerQuery()
  #define updateTimers(iterations) updateTimerQueries(iterations)
  #define reportTimer(type, name, iteration) reportTimerQuery(type, name, iteration)
#else
  #define startTimer(type)
  #define stopTimer()
  #define updateTimers(iterations)
  #define reportTimer(type, name, iteration)
#endif

namespace {
  // Magic numbers
  constexpr float pointSize = 3.f;
  constexpr int seedOffset = 7; // Generated by fair d20 die roll
  const float pi = std::acosf(-1);
  const float toDegMult = pi / 180.f;

  // For debug output
  void normalize(std::vector<float>& b) {
    const float max = *std::max_element(b.begin(), b.end());
    const float min = *std::min_element(b.begin(), b.end());
    const float range = max - min;
    std::transform(b.begin(), b.end(), b.begin(),
      [&range, &min](const auto& v) { return (v - min) / range; });
  }

  // Random number generation
  // Yeah yeah rand() is bad
  template <typename T>
  inline T next1D() {
    constexpr T next1DDiv = static_cast<T>(1) / static_cast<T>(RAND_MAX + 1);
    return static_cast<T>(rand()) * next1DDiv;
  }

  GLSL(depth_vert_src, 430,
    layout(location = 0) in vec4 point;
    layout(std430, binding = 0) buffer BoundsInterface { 
      vec3 minBounds;
      vec3 maxBounds;
      vec3 range;
      vec3 invRange;
    };
    uniform mat4 transformation;

    void main() {
      // Transform point into [0, 1] space
      vec3 position = (point.xyz - minBounds) * invRange;

      // Apply camera transformation
      position = vec3(transformation * vec4(position, 1));
      
      // Transform point into [-1, 1] clip space
      gl_Position =  vec4(position * 2.f - 1.f, 1.f);
    }
  );

  GLSL(depth_geom_src, 430,
    layout (points) in;
    layout (points, max_vertices = 1) out;

    void main() {
      // Emit point for front depth boundary
      gl_Layer = 0;
      gl_Position = gl_in[0].gl_Position;
      EmitVertex();
      EndPrimitive();

      // Emit point for back depth boundary
      gl_Layer = 1;
      gl_Position = gl_in[0].gl_Position * vec4(1, 1, -1, 1);
      EmitVertex();
      EndPrimitive();
    }
  );

  GLSL(field_src, 430,
    layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
    layout(std430, binding = 0) buffer PosInterface { vec3 Positions[]; };
    layout(std430, binding = 1) buffer BoundsInterface { 
      vec3 minBounds;
      vec3 maxBounds;
      vec3 range;
      vec3 invRange;
    };
    layout(rgba32f, binding = 0) writeonly uniform image3D fields_texture;
    
    uniform uint num_points;
    uniform uvec3 texture_size;
    uniform mat4 invTransformation;
    uniform sampler2DArray depth_textures;

    // Reduction components
    const uint groupSize = gl_WorkGroupSize.x;
    const uint halfGroupSize = groupSize / 2;
    shared vec4 reductionArray[halfGroupSize];

    void main() {
      // Location of current workgroup
      ivec2 xy = ivec2(gl_WorkGroupID.xy);
      uint lid = gl_LocalInvocationIndex.x;
      
      // Query depth map
      float zNear = texelFetch(depth_textures, ivec3(xy, 0), 0).x;
      float zFar = 1.f - texelFetch(depth_textures, ivec3(xy, 1), 0).x;
      
      // Stencil test using depth
      bool isOccupied = !(zNear == 1.f && zFar == 0.f);
      if (!isOccupied) {
        if (lid < texture_size.z && gl_WorkGroupID.z == 0) {
          ivec3 xyz = ivec3(xy, lid);
          imageStore(fields_texture, xyz, vec4(0));
        }
        return;
      }
      
      // Add padding to depth range
      float zRange = zFar - zNear;
      zNear -= 0.1f * zRange;
      zFar += 0.1f * zRange;

      for (uint z = gl_WorkGroupID.z; 
            z < texture_size.z; 
            z += gl_NumWorkGroups.z) {
        // Pixel location of current loop
        ivec3 xyz = ivec3(xy, z);
        
        // Map xyz to [0, 1], actually bound by [zNear, zFar] though
        vec3 domain_pos = (vec3(xyz) + vec3(0.5)) / texture_size;

        // Map z from [zNear, zFar] to [0, 1] using queried depth
        domain_pos.z = domain_pos.z * (zFar - zNear) + zNear;

        // Undo camera transformation
        domain_pos = vec3(invTransformation * vec4(domain_pos, 1));

        // Map to domain bounds
        domain_pos = domain_pos * range + minBounds;

        // Iterate over points to obtain density/gradient
        vec4 v = vec4(0);
        for (uint i = lid; i < num_points; i += groupSize) {
          vec3 t = domain_pos - Positions[i];
          float t_stud = 1.f / (1.f + dot(t, t));
          vec3 t_stud_2 = t * (t_stud * t_stud);

          // Field layout is: S, V.x, V.y, V.z
          v += vec4(t_stud, t_stud_2);
        }
        
        // Perform reduce add over all computed points for this pixel
        if (lid >= halfGroupSize) {
          reductionArray[lid - halfGroupSize] = v;
        }
        barrier();
        if (lid < halfGroupSize) {
          reductionArray[lid] += v;
        }
        for (uint i = halfGroupSize / 2; i > 1; i /= 2) {
          barrier();
          if (lid < i) {
            reductionArray[lid] += reductionArray[lid + i];
          }
        }
        barrier();
        if (lid < 1) {
          vec4 reducedArray = reductionArray[0] + reductionArray[1];
          imageStore(fields_texture, xyz, reducedArray);
        }
        barrier();
      }
    }
  );

  GLSL(interp_src, 430,
    layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
    layout(std430, binding = 0) buffer Pos{ vec3 Positions[]; };
    layout(std430, binding = 1) buffer Val { vec4 Values[]; };
    layout(std430, binding = 2) buffer BoundsInterface { 
      vec3 minBounds;
      vec3 maxBounds;
      vec3 range;
      vec3 invRange;
    };

    uniform uint num_points;
    uniform mat4 transformation;
    uniform sampler2DArray depth_textures;
    uniform sampler3D fields_texture;

    void main() {
      // Grid stride loop, straight from CUDA, scales better for very large N
      for (uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationIndex.x;
          i < num_points;
          i += gl_WorkGroupSize.x * gl_NumWorkGroups.x) {
        // Map position of point to [0, 1]
        vec3 position = (Positions[i] - minBounds) * invRange;
        
        // Apply optional camera transformation
        position = vec3(transformation * vec4(position, 1));

        // Query the depth texture for z-bounds
        float zNear = texture(depth_textures, vec3(position.xy, 0)).x;
        float zFar = 1.f - texture(depth_textures, vec3(position.xy, 1)).x;

        float zRange = zFar - zNear;
        zNear -= 0.1f * zRange;
        zFar += 0.1f * zRange;

        // Map z-position to [zNear, zFar]
        position.z = (position.z - zNear) / (zFar - zNear);

        // Sample texture at position
        Values[i] = texture(fields_texture, position.xyz);
      }
    }
  );

  GLSL(debug_src, 430,
    layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
    layout(r32f, binding = 0) writeonly uniform image2D debug_texture;
    uniform sampler2DArray depth_textures;
    
    void main() {
      uvec2 xy = gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy;
      ivec2 texture_size = textureSize(depth_textures, 0).xy;
      if (xy.x >= texture_size.x || xy.y >= texture_size.y) {
        return;
      }
      vec2 px = (vec2(xy) + vec2(0.5f)) / vec2(texture_size);

      // Query the depth textures
      float zNear = texture(depth_textures, vec3(px, 0)).x;
      float zFar = 1.f - texture(depth_textures, vec3(px, 1)).x;
      
      // Store difference
      float z = zFar- zNear;
      imageStore(debug_texture, ivec2(xy), vec4(z));
    }
  );
}

namespace hdi::dr {
  DepthFieldComputation::DepthFieldComputation()
  : _initialized(false), _iteration(0), _w(0), _h(0), _d(0) {
    // ...
  }

  DepthFieldComputation::~DepthFieldComputation() {
    if (_initialized) {
      clean();
    }
  }

  void DepthFieldComputation::initialize(const TsneParameters& params, 
                                          unsigned n) {
    _params = params;

    // Initialize rng, yeah yeah std::rand() is bad.
    std::srand(_params._seed + seedOffset);

    // Build shader programs
    try {
      for (auto& program : _programs) {
        program.create();
      }
      _programs[PROGRAM_DEPTH].addShader(VERTEX, depth_vert_src);
      _programs[PROGRAM_DEPTH].addShader(GEOMETRY, depth_geom_src);
      _programs[PROGRAM_FIELD_3D].addShader(COMPUTE, field_src); 
      _programs[PROGRAM_INTERP].addShader(COMPUTE, interp_src);
      _programs[PROGRAM_DEBUG].addShader(COMPUTE, debug_src);
      for (auto& program : _programs) {
        program.build();
      }
    } catch (const ShaderLoadingException& e) {
      std::cerr << e.what() << std::endl;
      exit(0); // yeah no, not recovering from this catastrophy
    }

    #ifdef FIELD_QUERY_TIMER_ENABLED
      // Generate timer query handles and reset values
      glGenQueries(_timerHandles.size(), _timerHandles.data());
      _timerValues.fill({0l, 0l });
    #endif // FIELD_QUERY_TIMER_ENABLED

    // Generate 2d depth texture array
    glGenTextures(1, &_textures[TEXTURE_DEPTH]);
    glBindTexture(GL_TEXTURE_2D_ARRAY, _textures[TEXTURE_DEPTH]);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    // Generate 3d fields texture
    glGenTextures(1, &_textures[TEXTURE_FIELD_3D]);
    glBindTexture(GL_TEXTURE_3D, _textures[TEXTURE_FIELD_3D]);
    glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glGenTextures(1, &_textures[TEXTURE_DEBUG]);
    glBindTexture(GL_TEXTURE_2D, _textures[TEXTURE_DEBUG]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);


    // Generate framebuffer with depth texture attached only
    glGenFramebuffers(1, &_depth_fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, _depth_fbo);
    glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, _textures[TEXTURE_DEPTH], 0);
    glDrawBuffer(GL_NONE);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    
    glGenVertexArrays(1, &_point_vao);
    _iteration = 0;
    _initialized = true;
  }

  void DepthFieldComputation::clean() {
    glDeleteTextures(_textures.size(), _textures.data());
    glDeleteFramebuffers(1, &_depth_fbo);
    glDeleteVertexArrays(1, &_point_vao);
#ifdef FIELD_QUERY_TIMER_ENABLED
    glDeleteQueries(_timerHandles.size(), _timerHandles.data());
#endif // FIELD_QUERY_TIMER_ENABLED
    for (auto& program : _programs) {
      program.destroy();
    }
    _iteration = 0;
    _initialized = false;
  }

  void DepthFieldComputation::updateView() {
    constexpr float pi2 = 2.f * static_cast<float>(M_PI);
    const float r1 = next1D<float>(), r2 = next1D<float>(), r3 = next1D<float>();

    // Generate random point on unit sphere as direction
    float z = 1.f - 2.f * r1;
    float r = std::sqrtf(1.f - z * z);
    float phi = pi2 * r2;
    float x = std::cosf(phi) * r;
    float y = std::sinf(phi) * r;

    // Generate rotation towards direction vector
    QVector3D v(0, 0, 1);
    QVector3D a(x, y, z);
    QVector3D b = QVector3D::crossProduct(v, a);
    float theta1 = std::acosf(QVector3D::dotProduct(v, a)) * toDegMult;

    // Generate random rotation around direction vector
    float theta2 = 360.f * r3;

    // Center point in [-0.5, 0.5], rotate, and uncenter again
    _viewMatrix = QMatrix4x4(); 
    _viewMatrix.translate(0.5f, 0.5f, 0.5f); // shift away from center again
    _viewMatrix.rotate(theta1, b);
    _viewMatrix.rotate(theta2, a);
    _viewMatrix.translate(-0.5f, -0.5f, -0.5f); // shift to center
  }

  void DepthFieldComputation::compute(unsigned w, unsigned h, unsigned d,
                float function_support, unsigned n,
                GLuint position_buff, GLuint bounds_buff, GLuint interp_buff,
                Bounds3D bounds) {
    // Generate new view matrix first
    updateView();
    
    QMatrix4x4 inverse = _viewMatrix.inverted();
    Point3D minBounds = bounds.min;
    Point3D range = bounds.range();

    // Only update texture dimensions if they have changed
    bool refresh = false;
    if (_w != w || _h != h || _d != d) {
      refresh = true;
      _w = w;
      _h = h;
      _d = d;
    }

    // Compute depth textures
    { 
      startTimer(TIMER_DEPTH);

      // Configure framebuffer depth texture
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D_ARRAY, _textures[TEXTURE_DEPTH]);
      if (refresh) {
        glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_DEPTH_COMPONENT32F, _w, _h, 2, 0, GL_DEPTH_COMPONENT, GL_FLOAT, nullptr);
      }

      // Bind bounds buffer
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, bounds_buff);
      
      // Bind uniforms to shader
      auto& program = _programs[PROGRAM_DEPTH];
      program.bind();
      program.uniformMatrix4f("transformation", _viewMatrix.data());
      
      // Prepare for drawing with depth test
      glBindFramebuffer(GL_FRAMEBUFFER, _depth_fbo);
      glEnable(GL_DEPTH_TEST);
      glDepthFunc(GL_LESS);
      glDepthMask(GL_TRUE);
      glViewport(0, 0, _w, _h);
      glClearColor(0.f, 0.f, 0.f, 0.f);
      glClearDepthf(1.f);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      
      // Draw a point at each embedding position
      glBindVertexArray(_point_vao);
      glBindBuffer(GL_ARRAY_BUFFER, position_buff);
      glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, nullptr);
      glEnableVertexAttribArray(0);
      glPointSize(pointSize);
      glDrawArrays(GL_POINTS, 0, n);

      // Cleanup
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      glDisable(GL_DEPTH_TEST);
      _programs[PROGRAM_DEPTH].release();

      stopTimer();
    }

    // Compute fields 3D texture
    {
      startTimer(TIMER_FIELD_3D);

      auto &program = _programs[PROGRAM_FIELD_3D];
      program.bind();

      // Define fields texture format
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_3D, _textures[TEXTURE_FIELD_3D]);
      if (refresh) {
        glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA32F, _w, _h, _d, 0, GL_RGBA, GL_FLOAT, nullptr);
      }

      // Attach depth texture for sampling
      glBindTexture(GL_TEXTURE_2D_ARRAY, _textures[TEXTURE_DEPTH]);

      // Set uniforms in compute shader
      program.uniform1ui("num_points", n);
      program.uniform3ui("texture_size", _w, _h, _d);
      program.uniformMatrix4f("invTransformation", inverse.data());
      program.uniform1i("depth_textures", 0);

      // Bind textures and buffers
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, position_buff);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, bounds_buff);
      glBindImageTexture(0, _textures[TEXTURE_FIELD_3D], 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_RGBA32F);

      // Perform computation
      glDispatchCompute(_w, _h, 2);
      glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
      
      program.release();
      stopTimer();
    }

    // Query field texture for positional values
    {
      startTimer(TIMER_INTERP);

      auto &program = _programs[PROGRAM_INTERP];
      program.bind();

      // Bind the textures for this shader
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D_ARRAY, _textures[TEXTURE_DEPTH]);
      glActiveTexture(GL_TEXTURE1);
      glBindTexture(GL_TEXTURE_3D, _textures[TEXTURE_FIELD_3D]);

      // Bind buffers for this shader
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, position_buff);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, interp_buff);
      glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, bounds_buff);

      // Bind uniforms for this shader
      program.uniform1ui("num_points", n);
      program.uniformMatrix4f("transformation", _viewMatrix.data());
      program.uniform1i("depth_textures", 0);
      program.uniform1i("fields_texture", 1);

      // Dispatch compute shader
      glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
      glDispatchCompute(128, 1, 1);

      program.release();
      stopTimer();
    }
    
    // Compute debug texture
    {
      auto& program = _programs[PROGRAM_DEBUG];
      program.bind();

      glBindTexture(GL_TEXTURE_2D, _textures[TEXTURE_DEBUG]);
      if (refresh) {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, _w, _h, 0, GL_RED, GL_FLOAT, nullptr);
      }

      // Bind the textures for this shader
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D_ARRAY, _textures[TEXTURE_DEPTH]);
      program.uniform1i("depth_textures", 0);
      glBindImageTexture(0, _textures[TEXTURE_DEBUG], 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R32F);

      // Perform computation
      glDispatchCompute((_w / 8) + 1, (_h / 8) + 1, 1);
      glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);

      program.release();
    }

    // Test output textures every 100 iterations
    #ifdef FIELD_IMAGE_OUTPUT
    if (_iteration % 10 == 0) {
      // Output depth textures
      {
        std::vector<float> depth(w * h * 2, 0.f);
        glBindTexture(GL_TEXTURE_2D_ARRAY, _textures[TEXTURE_DEPTH]);
        glGetTexImage(GL_TEXTURE_2D_ARRAY, 0, GL_DEPTH_COMPONENT, GL_FLOAT, depth.data());
        const std::string name = "images/depth_";
        
        std::vector<float> buffer(w * h, 0.f);
        for (int i = 0; i < 2; i++) {
          for (int j = 0; j < w * h; j++) {
            buffer[j] = depth[i *  w * h + j];
          }
          // normalize(buffer);
          hdi::utils::valuesToImage(name + std::to_string(i) + "_" + std::to_string(_iteration), buffer, w, h, 1);
        }
      }
      
      // Output debug textures
      {
        std::vector<float> debug(w * h, 0.f);
        glBindTexture(GL_TEXTURE_2D, _textures[TEXTURE_DEBUG]);
        glGetTexImage(GL_TEXTURE_2D, 0, GL_RED, GL_FLOAT, debug.data());
        hdi::utils::valuesToImage("images/debug_" + std::to_string(_iteration), debug, w, h, 1);
      }
      
      // Output 3d fields texture
      /* { 
        std::vector<float> field(w * h * d * 4, 0.f);
        glBindTexture(GL_TEXTURE_3D, _textures[TEXTURE_FIELD_3D]);
        glGetTexImage(GL_TEXTURE_3D, 0, GL_RGBA, GL_FLOAT, field.data());

        const std::array<std::string, 4> names = { 
          "images/3D/density_",
          "images/3D/gradient_x_",
          "images/3D/gradient_y_",
          "images/3D/gradient_z_" 
        };

        std::vector<float> buffer(w * h, 0.f);
        for (int k = 0; k < d; k++) {
          for (int i = 0; i < 4; i++) {
            for (int j = 0; j < w * h; j++) {
              buffer[j] = field[(k * w * h * 4) + 4 * j + i];
            }
            normalize(buffer);
            hdi::utils::valuesToImage(names[i] + std::to_string(_iteration) + "_" + std::to_string(k), buffer, w, h, 1);
          }
        }
      } */
    }
    #endif // FIELD_IMAGE_OUTPUT
    
    updateTimers(_iteration);
    if (_iteration >= _params._iterations - 1) {
      // Output timer values
      reportTimer(TIMER_DEPTH, "Depth", _iteration);
      reportTimer(TIMER_FIELD_3D, "Field", _iteration);
      reportTimer(TIMER_INTERP, "Interp", _iteration);
    }
    _iteration++;
  }

#ifdef FIELD_QUERY_TIMER_ENABLED
  void DepthFieldComputation::startTimerQuery(TimerType type) {
    glBeginQuery(GL_TIME_ELAPSED, _timerHandles[type]);
  }

  void DepthFieldComputation::stopTimerQuery() {
    glEndQuery(GL_TIME_ELAPSED);
  }
  
  bool DepthFieldComputation::updateTimerQuery(TimerType type, unsigned iteration) {
    const auto& handle = _timerHandles[type];
    
    // Return if query data for this handle is unavailable
    int i = 0;
    glGetQueryObjectiv(handle, GL_QUERY_RESULT_AVAILABLE, &i);
    if (!i) {
      return false;
    }
    
    // Obtain query value
    auto& values = _timerValues[type];
    glGetQueryObjecti64v(handle, GL_QUERY_RESULT, &values[TIMER_LAST_QUERY]);
    
    // Compute incremental average
    values[TIMER_AVERAGE] 
      = values[TIMER_AVERAGE] 
      + (values[TIMER_LAST_QUERY] - values[TIMER_AVERAGE]) 
      / (iteration + 1);

    return true;
  }

  void DepthFieldComputation::updateTimerQueries(unsigned iteration) {
    std::deque<TimerType> types = {
      TIMER_DEPTH,
      TIMER_FIELD_3D,
      TIMER_INTERP
    };

    // Query until all timer data is available and obtained
    while (!types.empty()) {
      const auto type = types.front();
      types.pop_front();
      if (!updateTimerQuery(type, iteration)) {
        types.push_back(type);
      }
    }
  }

  void DepthFieldComputation::reportTimerQuery(TimerType type, const std::string& name, unsigned iteration) {
    const double ms = static_cast<double>(_timerValues[type][TIMER_AVERAGE]) / 1000000.0;
    utils::secureLogValue(
      _logger, 
      name + " shader average (" + std::to_string(iteration) + " iters, ms)",
      ms);
  }
#endif // FIELD_QUERY_TIMER_ENABLED
}